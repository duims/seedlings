"""Practising really understanding implementing algorithm concepts == actually implementing some algorithms
This algorithm was invented in the late 60's by Robert Floyd, a computer science professor at Stanford. 

The implementation of Linked Lists: Each node is a dict containing keys: data, the value in the node, and next, which points to the next node in the list.
Each node only points to 1 other node, or None.

"""

import unittest
import random


def tortoiseHare(linkedList):
    if linkedList == None or linkedList['next'] == None or linkedList['next']['next'] == None:
        # short Circuitry at work! :)
        return False

    slow = linkedList
    fast = linkedList['next']['next']
    while slow != fast:
        if fast['next'] == None or fast['next']['next'] == None:
            return False
        else:
            fast = fast['next']['next']
        slow = slow['next']
    return True



def makeLinkedList(_list):
    
    linkedList = None
    
    #iterate backwards through the originallist and append values to the head of the linked list.
    #Useful because we only have unidirectional pointers.

    for i in range(len(_list) - 1, -1, -1):
        linkedList = insertHead(linkedList, _list[i])
    return linkedList


def insertAtEnd(linkedList, value):
    newNode = {}
    newNode['data'] = value
    newNode['next'] = None
    ptr = linkedList
    while ptr['next'] != None:
        ptr = ptr['next']
    ptr['next'] = newNode
    return linkedList


def insertHead(linkedList, value):
    newNode = {}
    newNode['data'] = value
    newNode['next'] = linkedList
    return newNode


def makeALoop(linkedList, ptMe):
    #ptMe is the "index" value of the element that starts the cycle.
    ptr = linkedList
    for i in range(ptMe - 1):
        ptr = ptr['next']
    end = linkedList
    while end['next'] != None:
        end = end['next']
    end['next'] = ptr
    return linkedList


def printLinkedList(linkedList):
    printThis = "["
    ptr = linkedList
    while ptr != None:
        printThis = printThis + str(ptr['data'])
        if ptr['next'] != None:
            printThis = printThis + ", "
        ptr = ptr['next']

    printThis = printThis + "]"
    print (printThis)
    return None


class TestFunctions(unittest.TestCase):
    """
        Testing functions: Tests lists of variable lengths with cycles and without cycles.
        Cycles generated by passing list through makeALoop(theList, randomInt).
        The integer must be less than the length of the list.



        """

    def setUp(self):
        #test cases with no cycles
        self.empty=makeLinkedList([])
        self.oneElem=makeLinkedList([1])
        self.twoElem=makeLinkedList([2, 3])
        self.threeElem=makeLinkedList([4, 5, 6])
        self.longList=makeLinkedList([3, 34, 5, 6, 3, 2])

        #test cases with cycles
        self.oneLinked=makeALoop(self.oneElem, 0)
        self.twoLinked=makeALoop(self.twoElem, 1)
        self.threeLinked=makeALoop(self.threeElem, 0)
        self.longLinked=makeALoop(self.longList, (random.randint(0, 6)))

    #test all the straight lists:

    def test_emptyCycleFree(self):
        #Empty LL should be false.
        self.assertFalse(tortoiseHare(self.empty))
    
    def test_oneElemCycleFree(self):
        #one elem with no cycles should be false.
        self.assertFalse(tortoiseHare(self.oneElem))

    def test_twoElemCycleFree(self):
        #two elem with no cycles should be false.
        self.assertFalse(tortoiseHare(self.twoElem))

    def test_threeElemCycleFree(self):
        #three elements and no cycles should be false
        self.assertFalse(tortoiseHare(self.threeElem))
        
    def test_longListCycleFree(self):
        #linked list with no cycles should be false
        print(self)
        self.assertFalse(tortoiseHare(self.longList))

        
    # test all the cycles:

    def test_oneLinked(self):
        #should be true
        self.assertTrue(tortoiseHare(self.oneLinked))
        
    def test_twoLinked(self):
        #should be true
        self.assertTrue(tortoiseHare(self.twoLinked))
        
    def test_threeLinked(self):
        #should be true
        self.assertTrue(tortoiseHare(self.threeLinked))  

    def test_longLinked(self):
        #should be true
        self.assertTrue(tortoiseHare(self.longLinked))
                               

        


if __name__ == '__main__':
    unittest.main()
